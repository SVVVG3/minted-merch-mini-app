/**
 * EIP-712 Signature Verification for Free Order Claims
 * 
 * This module handles:
 * 1. Generating typed data messages for free orders (no PII)
 * 2. Verifying signatures server-side
 * 3. Checking nonces to prevent replay attacks
 * 4. Rate limiting free order claims
 */

import { verifyTypedData, getAddress } from 'viem';
import { supabaseAdmin } from './supabase';

// USDC contract on Base - used as verifyingContract to help wallets recognize the signature
const USDC_BASE_ADDRESS = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';

// EIP-712 Domain - identifies our application
// verifyingContract helps wallets recognize this as a legitimate signature request
export const FREE_ORDER_DOMAIN = {
  name: 'Minted Merch',
  version: '1',
  chainId: 8453, // Base mainnet
  verifyingContract: USDC_BASE_ADDRESS,
};

// EIP-712 Types - structure of the message (NO PII)
export const FREE_ORDER_TYPES = {
  FreeOrderClaim: [
    { name: 'orderId', type: 'string' },
    { name: 'fid', type: 'uint256' },
    { name: 'discountCode', type: 'string' },
    { name: 'itemCount', type: 'uint256' },
    { name: 'nonce', type: 'uint256' },
  ],
};

// Maximum age of a signature (5 minutes)
const SIGNATURE_MAX_AGE_MS = 5 * 60 * 1000;

/**
 * Generate the typed data message for a free order claim
 * IMPORTANT: This contains NO PII - only order identifiers
 * 
 * @param {Object} orderData - Order information
 * @param {string} orderData.orderId - Unique order identifier
 * @param {number} orderData.fid - Farcaster ID
 * @param {string} orderData.discountCode - The discount code used
 * @param {number} orderData.itemCount - Number of items in order
 * @returns {Object} The message to be signed
 */
export function generateFreeOrderMessage(orderData) {
  const { orderId, fid, discountCode, itemCount } = orderData;
  
  // Use timestamp as nonce for uniqueness
  const nonce = Date.now();
  
  return {
    orderId: String(orderId),
    fid: BigInt(fid),
    discountCode: String(discountCode || 'NONE').toUpperCase(),
    itemCount: BigInt(itemCount || 1),
    nonce: BigInt(nonce),
  };
}

/**
 * Get the full typed data structure for signing
 * This is what gets passed to the wallet for signing
 * 
 * @param {Object} message - The message generated by generateFreeOrderMessage
 * @returns {Object} Full typed data structure for EIP-712
 */
export function getTypedDataForSigning(message) {
  return {
    domain: FREE_ORDER_DOMAIN,
    types: FREE_ORDER_TYPES,
    primaryType: 'FreeOrderClaim',
    message: message,
  };
}

/**
 * Verify a free order claim signature
 * 
 * @param {Object} params - Verification parameters
 * @param {string} params.signature - The EIP-712 signature
 * @param {Object} params.message - The message that was signed
 * @param {string} params.expectedAddress - The wallet address that should have signed
 * @returns {Object} Verification result
 */
export async function verifyFreeOrderSignature({ signature: rawSignature, message, expectedAddress }) {
  try {
    console.log('üîê Verifying free order signature:', {
      hasSignature: !!rawSignature,
      signatureLength: rawSignature?.length,
      expectedAddress: expectedAddress?.substring(0, 10) + '...',
      orderId: message?.orderId,
      fid: message?.fid?.toString(),
      nonce: message?.nonce?.toString()
    });

    // Validate inputs
    if (!rawSignature || typeof rawSignature !== 'string') {
      return {
        success: false,
        error: 'Invalid signature format',
        code: 'INVALID_SIGNATURE_FORMAT'
      };
    }
    
    let signature = rawSignature;
    
    // Validate signature length - should be 132 chars (0x + 130 hex) or 130 without prefix
    const expectedLengths = [132, 130];
    if (!expectedLengths.includes(signature.length)) {
      console.error('‚ùå Invalid signature length:', signature.length, 'expected 132 or 130');
      
      // Try to extract a valid signature if embedded in malformed data
      const sigMatch = signature.match(/0x[a-fA-F0-9]{130}/);
      if (sigMatch) {
        console.log('üìù Found valid signature embedded in data, extracting...');
        signature = sigMatch[0];
      } else {
        return {
          success: false,
          error: `invalid signature length`,
          code: 'INVALID_SIGNATURE_LENGTH',
          details: {
            received: signature.length,
            expected: 132,
            hint: 'Signature should be a hex string starting with 0x (132 chars total)'
          }
        };
      }
    }
    
    // Ensure 0x prefix
    if (!signature.startsWith('0x')) {
      signature = '0x' + signature;
    }
    
    // Log signature details for debugging
    console.log('üîç Signature details:', {
      length: signature.length,
      prefix: signature.substring(0, 10),
      suffix: signature.substring(signature.length - 10)
    });

    if (!expectedAddress) {
      return {
        success: false,
        error: 'Expected wallet address is required',
        code: 'MISSING_ADDRESS'
      };
    }

    if (!message || !message.orderId || message.fid === undefined) {
      return {
        success: false,
        error: 'Invalid message format',
        code: 'INVALID_MESSAGE_FORMAT'
      };
    }

    // Check signature age (nonce is timestamp)
    const signatureAge = Date.now() - Number(message.nonce);
    if (signatureAge > SIGNATURE_MAX_AGE_MS) {
      console.log('‚è∞ Signature expired:', {
        signatureAge: signatureAge / 1000,
        maxAge: SIGNATURE_MAX_AGE_MS / 1000
      });
      return {
        success: false,
        error: 'Signature has expired. Please try again.',
        code: 'SIGNATURE_EXPIRED'
      };
    }

    // Check if nonce has already been used (prevents replay attacks)
    const nonceCheck = await checkNonceUsed(message.nonce.toString());
    if (nonceCheck.used) {
      console.log('üîÑ Nonce already used:', message.nonce.toString());
      return {
        success: false,
        error: 'This signature has already been used',
        code: 'NONCE_ALREADY_USED'
      };
    }

    // Normalize the expected address
    const normalizedExpectedAddress = getAddress(expectedAddress);

    // Verify the signature using viem
    const isValid = await verifyTypedData({
      address: normalizedExpectedAddress,
      domain: FREE_ORDER_DOMAIN,
      types: FREE_ORDER_TYPES,
      primaryType: 'FreeOrderClaim',
      message: message,
      signature: signature,
    });

    if (!isValid) {
      console.log('‚ùå Signature verification failed - signature does not match');
      return {
        success: false,
        error: 'Invalid signature - wallet address mismatch',
        code: 'SIGNATURE_MISMATCH'
      };
    }

    console.log('‚úÖ Signature verified successfully');
    return {
      success: true,
      verified: true,
      signerAddress: normalizedExpectedAddress
    };

  } catch (error) {
    console.error('‚ùå Signature verification error:', error);
    return {
      success: false,
      error: `Signature verification failed: ${error.message}`,
      code: 'VERIFICATION_ERROR'
    };
  }
}

/**
 * Check if a nonce has already been used
 * 
 * @param {string} nonce - The nonce to check
 * @returns {Object} Result with 'used' boolean
 */
async function checkNonceUsed(nonce) {
  try {
    const { data, error } = await supabaseAdmin
      .from('signature_claim_nonces')
      .select('id')
      .eq('nonce', nonce)
      .single();

    if (error && error.code !== 'PGRST116') { // PGRST116 = not found
      console.error('Error checking nonce:', error);
      throw error;
    }

    return { used: !!data };
  } catch (error) {
    console.error('Error checking nonce:', error);
    // On error, assume not used (will be caught by unique constraint on insert)
    return { used: false };
  }
}

/**
 * Mark a nonce as used after successful order creation
 * 
 * @param {Object} params - Parameters
 * @param {string} params.nonce - The nonce to mark as used
 * @param {number} params.fid - User's FID
 * @param {string} params.walletAddress - User's wallet address
 * @param {string} params.orderId - The order ID created
 * @returns {Object} Result
 */
export async function markNonceUsed({ nonce, fid, walletAddress, orderId }) {
  try {
    const { error } = await supabaseAdmin
      .from('signature_claim_nonces')
      .insert({
        nonce: nonce.toString(),
        fid: fid,
        wallet_address: walletAddress.toLowerCase(),
        order_id: orderId
      });

    if (error) {
      // If duplicate, that's fine - nonce is already marked as used
      if (error.code === '23505') { // Unique violation
        console.log('Nonce already marked as used (concurrent request)');
        return { success: true, alreadyUsed: true };
      }
      throw error;
    }

    return { success: true };
  } catch (error) {
    console.error('Error marking nonce as used:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Check if user can claim a free order (rate limiting)
 * 
 * @param {number} fid - User's FID
 * @returns {Object} Rate limit status
 */
export async function checkFreeOrderRateLimit(fid) {
  try {
    const { data, error } = await supabaseAdmin
      .rpc('check_free_order_claim_limit', { p_fid: fid });

    if (error) {
      console.error('Error checking rate limit:', error);
      // On error, allow the claim (don't block users due to DB issues)
      return {
        allowed: true,
        dailyRemaining: 3,
        hourlyOk: true,
        error: error.message
      };
    }

    return {
      allowed: data.allowed,
      dailyRemaining: data.daily_remaining,
      hourlyOk: data.hourly_ok,
      dailyCount: data.daily_count || 0,
      nextAvailable: data.next_available
    };
  } catch (error) {
    console.error('Error checking rate limit:', error);
    return {
      allowed: true,
      dailyRemaining: 3,
      hourlyOk: true,
      error: error.message
    };
  }
}

/**
 * Record a free order claim (for rate limiting)
 * 
 * @param {number} fid - User's FID
 * @returns {Object} Result
 */
export async function recordFreeOrderClaim(fid) {
  try {
    const { error } = await supabaseAdmin
      .rpc('record_free_order_claim', { p_fid: fid });

    if (error) {
      console.error('Error recording free order claim:', error);
      return { success: false, error: error.message };
    }

    return { success: true };
  } catch (error) {
    console.error('Error recording free order claim:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Full validation for a free order signature claim
 * Combines all checks: signature, nonce, rate limit
 * 
 * @param {Object} params - Validation parameters
 * @param {string} params.signature - The EIP-712 signature
 * @param {Object} params.message - The message that was signed
 * @param {string} params.expectedAddress - Expected signer wallet address
 * @param {number} params.fid - User's FID
 * @returns {Object} Validation result
 */
export async function validateFreeOrderClaim({ signature, message, expectedAddress, fid }) {
  console.log('üîí Validating free order claim:', {
    orderId: message?.orderId,
    fid: fid,
    walletPrefix: expectedAddress?.substring(0, 10)
  });

  // Step 1: Check rate limit
  const rateLimit = await checkFreeOrderRateLimit(fid);
  if (!rateLimit.allowed) {
    const reason = !rateLimit.hourlyOk 
      ? 'Please wait at least 1 hour between free order claims'
      : `Daily limit reached (${rateLimit.dailyCount}/3). Try again tomorrow.`;
    
    return {
      success: false,
      error: reason,
      code: 'RATE_LIMITED',
      rateLimit: rateLimit
    };
  }

  // Step 2: Verify the signature
  const signatureResult = await verifyFreeOrderSignature({
    signature,
    message,
    expectedAddress
  });

  if (!signatureResult.success) {
    return signatureResult;
  }

  // Step 3: All validations passed
  return {
    success: true,
    verified: true,
    signerAddress: signatureResult.signerAddress,
    rateLimit: rateLimit
  };
}

